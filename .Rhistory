weather["sinf"] <- sin((2 * pi/ 365) * (weather["day"] - 1))
weather["cosf"] <- cos((2 * pi/ 365) * (weather["day"] - 1))
weather.bf90s <- weather[weather$year < 1990]
weather <- as.data.frame(read.csv("simplified-sfo-weather.csv"))
print(weather$year)
weather["sinf"] <- sin((2 * pi/ 365) * (weather["day"] - 1))
weather["cosf"] <- cos((2 * pi/ 365) * (weather["day"] - 1))
print(weather.bf90s)
weather <- as.data.frame(read.csv("simplified-sfo-weather.csv"))
print(weather$year)
weather["sinf"] <- sin((2 * pi/ 365) * (weather["day"] - 1))
weather["cosf"] <- cos((2 * pi/ 365) * (weather["day"] - 1))
weather.bf90s <- weather[weather$year <= 1990]
weather <- as.data.frame(read.csv("simplified-sfo-weather.csv"))
print(weather$year)
weather["sinf"] <- sin((2 * pi/ 365) * (weather["day"] - 1))
weather["cosf"] <- cos((2 * pi/ 365) * (weather["day"] - 1))
weather.bf90s <- weather[weather$year <= 1990,]
print(weather.bf90s)
line <- lm(temphigh ~ sinf + cosf, na.action=na.omit, data=weather)
print(summary(line))
weather <- as.data.frame(read.csv("simplified-sfo-weather.csv"))
print(weather)
weather["sinf"] <- sin((2 * pi/ 365) * (weather["day"] - 1))
weather["cosf"] <- cos((2 * pi/ 365) * (weather["day"] - 1))
weather.bf90s <- weather[weather$year <= 1990,]
print(weather.bf90s)
line <- lm(temphigh ~ sinf + cosf, na.action=na.omit, data=weather)
print(summary(line))
usethis::use_testthat()
ls
cd
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv")) sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")] Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X) m <- nrow(X) n <- nrow(Z)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X. resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df)) resid_new <- as.matrix(Z_df["precip"] - Z %*% coefficients(lm_X))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X. resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df)) resid_new <- as.matrix(Z_df["precip"] - Z %*% coefficients(lm_X))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - Z %*% coefficients(lm_X))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
print(C[2,2])
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
print(C)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
#print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
print(solve(t(X) %*% X)[2,2])
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
#print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
print((t(X) %*% X)[2,2])
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ sins + coss, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
#print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
print((t(X) %*% X)[2,2])
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["ones"] <- rep(c(1), times=nrow(sfo))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("ones", "sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("ones", "sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ ones + sins + coss - 1, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
#print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
print((t(X) %*% X)[2,2])
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["ones"] <- rep(c(1), times=nrow(sfo))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("ones", "sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("ones", "sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ ones + sins + coss - 1, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
library(expm)
library(dplyr)
comp_M <- function(Z, X) {
n <- nrow(Z)
I <- diag(x=1, nrow=n, ncol=n)
C <- I + Z %*% solve(t(X) %*% X) %*% t(Z)
return (sqrtm(solve(C)))
}
ss <- function(x) {
return (sum(x^2))
}
ps <- c()
sfo <- na.omit(read.csv("simplified-sfo-weather.csv"))
sfo["ones"] <- rep(c(1), times=nrow(sfo))
sfo["sins"] <- sin((2*pi/365) * (sfo["day"] - 1))
sfo["coss"] <- cos((2*pi/365) * (sfo["day"] - 1))
for (yr in c(1966:2020)) {
print(yr)
# Get the two covariates and response.
X_df <- sfo[sfo["year"]< yr,][c("ones", "sins", "coss", "precip")]
Z_df <- sfo[sfo["year"] == yr,][c("ones", "sins", "coss", "precip")] # Convert to matrix for compatibility with finding M.
X <- as.matrix(X_df)
Z <- as.matrix(Z_df)
d <- ncol(X)
m <- nrow(X)
n <- nrow(Z)
M <- comp_M(Z, X)
print(M[2,2])
# Regress precip on the two features plus intercept.
lm_X <- lm(precip ~ ones + sins + coss - 1, data=X_df)
# Using the same estimate for B_hat, find residuals using Z and X.
resid <- as.matrix(X_df["precip"] - predict(lm_X, newdata=X_df))
resid_new <- as.matrix(Z_df["precip"] - predict(lm_X, newdata=Z_df))
# Calculate statistic.
A <- (ss(M %*% resid_new)/n) / (ss(resid)/(m-d))
# Find the percentile of the value of A for a F_{n, m-d} dist.
#print(pf(A, df=n, df2=m-d, lower.tail=FALSE))
ps <- c(ps, pf(A, df=n, df2=m-d, lower.tail=FALSE))
}
install.packages("rstan")
devtools::install_version("StanHeaders", version = "2.19.0", repos = "http://cran.us.r-project.org")
install.package("rstan")
devtools::install_version("StanHeaders", repos = "http://cran.us.r-project.org")
install.packages("r-cran-rcppeigen")
install.packages("rcppeigen")
install.packages("RcppEigen")
source('~/Desktop/truncNormalMoments/R/functions.R')
source('~/Desktop/truncNormalMoments/R/functions.R')
source('~/Desktop/truncNormalMoments/R/functions.R')
source('~/Desktop/truncNormalMoments/R/functions.R')
source('~/Desktop/truncNormalMoments/R/functions.R')
getwd
getwd()
setwd("~/Desktop/truncNormalMoments/")
devtools::check()
devtools::check()
devtools::test()
rm(list = c("alphah", "alphal", "calculate_bias", "cordeiro_bias", "E_fisher", "estimate_jeffreys_mcmc", "find_A", "find_K", "get_cumulants", "get_cumulants_deriv", "get_deriv", "ll", "neg_log_post", "nlpost_Jeffreys", "prior", "ush", "usl"))
devtools::test()
